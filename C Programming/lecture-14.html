<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lecture 14: Call by Value and Call by Reference</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px 0;
            border-bottom: 3px solid #667eea;
        }
        
        .header h1 {
            color: #2c3e50;
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .header .course-info {
            color: #7f8c8d;
            margin: 10px 0;
            font-size: 1.1em;
        }
        
        .header .instructor {
            color: #34495e;
            font-weight: bold;
            margin-top: 15px;
        }
        
        .lecture-info {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .objectives {
            background: #f8f9fa;
            border-left: 5px solid #28a745;
            padding: 20px;
            margin: 30px 0;
            border-radius: 5px;
        }
        
        .objectives h3 {
            color: #28a745;
            margin-top: 0;
        }
        
        .section {
            margin: 40px 0;
        }
        
        .section h2 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            font-size: 1.8em;
        }
        
        .section h3 {
            color: #34495e;
            margin-top: 30px;
            font-size: 1.4em;
        }
        
        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #4299e1;
        }
        
        .code-block pre {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .output {
            background: #1a202c;
            color: #68d391;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            border-left: 4px solid #68d391;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .comparison-table th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: bold;
        }
        
        .comparison-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .comparison-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .highlight {
            background: linear-gradient(120deg, #a8edea 0%, #fed6e3 100%);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #ff6b6b;
        }
        
        .key-point {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .key-point h4 {
            color: #856404;
            margin-top: 0;
        }
        
        .diagram {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 2px dashed #3498db;
        }
        
        .memory-box {
            display: inline-block;
            margin: 10px;
            padding: 10px 15px;
            border: 2px solid #3498db;
            border-radius: 5px;
            background: white;
            font-family: monospace;
            min-width: 80px;
            text-align: center;
        }
        
        .arrow {
            display: inline-block;
            margin: 0 20px;
            font-size: 2em;
            color: #e74c3c;
        }
        
        .exercise {
            background: #e8f5e8;
            border-left: 5px solid #28a745;
            padding: 20px;
            margin: 30px 0;
            border-radius: 5px;
        }
        
        .exercise h4 {
            color: #28a745;
            margin-top: 0;
        }
        
        .summary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin: 40px 0;
        }
        
        .summary h3 {
            color: white;
            margin-top: 0;
        }
        
        .footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid #ecf0f1;
            color: #7f8c8d;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .lecture-info {
                flex-direction: column;
                text-align: center;
            }
            
            .comparison-table {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Call by Value and Call by Reference</h1>
            <div class="course-info">C Programming | BTech First Semester</div>
            <div class="instructor">Dr. Mohsin Dar | Assistant Professor | Cloud & Software Operations Cluster | SOCS | UPES</div>
        </div>
        
        <div class="lecture-info">
            <div><strong>Lecture 14</strong> | Unit III: Array and Function</div>
            <div>Duration: 50 minutes</div>
        </div>
        
        <div class="objectives">
            <h3>Learning Objectives</h3>
            <p>By the end of this lecture, students will be able to:</p>
            <ul>
                <li>Understand the difference between call by value and call by reference</li>
                <li>Implement functions using both parameter passing methods</li>
                <li>Use pointers to achieve call by reference in C</li>
                <li>Analyze when to use each method based on program requirements</li>
                <li>Debug common issues related to parameter passing</li>
            </ul>
        </div>
        
        <div class="section">
            <h2>1. Introduction to Parameter Passing</h2>
            <p>In C programming, when we call a function and pass arguments to it, there are different ways these arguments can be passed. The two primary methods are:</p>
            
            <div class="highlight">
                <h4>Parameter Passing Methods:</h4>
                <ul>
                    <li><strong>Call by Value:</strong> A copy of the actual argument is passed to the function</li>
                    <li><strong>Call by Reference:</strong> The address (reference) of the actual argument is passed to the function</li>
                </ul>
            </div>
            
            <p>Understanding these concepts is crucial for effective memory management and achieving desired program behavior.</p>
        </div>
        
        <div class="section">
            <h2>2. Call by Value</h2>
            
            <h3>2.1 Definition and Concept</h3>
            <p>In <strong>call by value</strong>, a copy of the actual parameter's value is passed to the function. The function works with this copy, and any changes made to the parameter inside the function do not affect the original variable.</p>
            
            <div class="diagram">
                <h4>Memory Representation - Call by Value</h4>
                <div class="memory-box">main()<br>x = 10</div>
                <span class="arrow">â†’</span>
                <div class="memory-box">function()<br>copy = 10</div>
                <p><em>Changes to 'copy' don't affect 'x'</em></p>
            </div>
            
            <h3>2.2 Example: Simple Call by Value</h3>
            <div class="code-block">
                <pre>
#include &lt;stdio.h&gt;

// Function that receives value by copy
void increment(int num) {
    num = num + 1;  // This only changes the local copy
    printf("Inside function: num = %d\n", num);
}

int main() {
    int x = 10;
    
    printf("Before function call: x = %d\n", x);
    increment(x);  // Pass value of x
    printf("After function call: x = %d\n", x);
    
    return 0;
}
                </pre>
            </div>
            
            <div class="output">
                <strong>Output:</strong><br>
                Before function call: x = 10<br>
                Inside function: num = 11<br>
                After function call: x = 10
            </div>
            
            <div class="key-point">
                <h4>Key Observation:</h4>
                <p>Notice that the value of 'x' in main() remains unchanged (10) even though 'num' was incremented inside the function. This demonstrates that the function worked with a copy of the original value.</p>
            </div>
            
            <h3>2.3 Characteristics of Call by Value</h3>
            <ul>
                <li><strong>Safety:</strong> Original data is protected from accidental modification</li>
                <li><strong>Memory Usage:</strong> Requires additional memory to store copies</li>
                <li><strong>Performance:</strong> Slower for large data structures due to copying overhead</li>
                <li><strong>Default Behavior:</strong> This is the default parameter passing method in C</li>
            </ul>
        </div>
        
        <div class="section">
            <h2>3. Call by Reference</h2>
            
            <h3>3.1 Definition and Concept</h3>
            <p>In <strong>call by reference</strong>, the address of the actual parameter is passed to the function. The function receives a pointer to the original variable, allowing it to directly modify the original value.</p>
            
            <div class="diagram">
                <h4>Memory Representation - Call by Reference</h4>
                <div class="memory-box">main()<br>x = 10<br>Address: 1000</div>
                <span class="arrow">â†’</span>
                <div class="memory-box">function()<br>*ptr â†’ 1000</div>
                <p><em>Changes through 'ptr' directly affect 'x'</em></p>
            </div>
            
            <h3>3.2 Example: Call by Reference using Pointers</h3>
            <div class="code-block">
                <pre>
#include &lt;stdio.h&gt;

// Function that receives address (reference)
void increment(int *num) {
    *num = *num + 1;  // This changes the original value
    printf("Inside function: *num = %d\n", *num);
}

int main() {
    int x = 10;
    
    printf("Before function call: x = %d\n", x);
    increment(&x);  // Pass address of x
    printf("After function call: x = %d\n", x);
    
    return 0;
}
                </pre>
            </div>
            
            <div class="output">
                <strong>Output:</strong><br>
                Before function call: x = 10<br>
                Inside function: *num = 11<br>
                After function call: x = 11
            </div>
            
            <div class="key-point">
                <h4>Key Observation:</h4>
                <p>The value of 'x' in main() has changed to 11 because the function modified the original variable through its address. The function parameter 'num' is a pointer that points to the memory location of 'x'.</p>
            </div>
            
            <h3>3.3 Practical Example: Swapping Two Numbers</h3>
            
            <h4>Incorrect Approach (Call by Value):</h4>
            <div class="code-block">
                <pre>
#include &lt;stdio.h&gt;

// This won't work - call by value
void swap_incorrect(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    printf("Inside function: a = %d, b = %d\n", a, b);
}

int main() {
    int x = 5, y = 10;
    
    printf("Before swap: x = %d, y = %d\n", x, y);
    swap_incorrect(x, y);
    printf("After swap: x = %d, y = %d\n", x, y);
    
    return 0;
}
                </pre>
            </div>
            
            <div class="output">
                <strong>Output:</strong><br>
                Before swap: x = 5, y = 10<br>
                Inside function: a = 10, b = 5<br>
                After swap: x = 5, y = 10
            </div>
            
            <h4>Correct Approach (Call by Reference):</h4>
            <div class="code-block">
                <pre>
#include &lt;stdio.h&gt;

// This works - call by reference
void swap_correct(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
    printf("Inside function: *a = %d, *b = %d\n", *a, *b);
}

int main() {
    int x = 5, y = 10;
    
    printf("Before swap: x = %d, y = %d\n", x, y);
    swap_correct(&x, &y);  // Pass addresses
    printf("After swap: x = %d, y = %d\n", x, y);
    
    return 0;
}
                </pre>
            </div>
            
            <div class="output">
                <strong>Output:</strong><br>
                Before swap: x = 5, y = 10<br>
                Inside function: *a = 10, *b = 5<br>
                After swap: x = 10, y = 5
            </div>
        </div>
        
        <div class="section">
            <h2>4. Detailed Comparison</h2>
            
            <table class="comparison-table">
                <tr>
                    <th>Aspect</th>
                    <th>Call by Value</th>
                    <th>Call by Reference</th>
                </tr>
                <tr>
                    <td><strong>Parameter Passed</strong></td>
                    <td>Copy of actual value</td>
                    <td>Address of actual variable</td>
                </tr>
                <tr>
                    <td><strong>Memory Usage</strong></td>
                    <td>More (due to copying)</td>
                    <td>Less (only address is copied)</td>
                </tr>
                <tr>
                    <td><strong>Original Data Safety</strong></td>
                    <td>Safe (cannot be modified)</td>
                    <td>Can be modified accidentally</td>
                </tr>
                <tr>
                    <td><strong>Function Parameter</strong></td>
                    <td>Regular variable</td>
                    <td>Pointer variable</td>
                </tr>
                <tr>
                    <td><strong>Function Call Syntax</strong></td>
                    <td>function_name(variable)</td>
                    <td>function_name(&variable)</td>
                </tr>
                <tr>
                    <td><strong>Function Definition</strong></td>
                    <td>return_type func(datatype param)</td>
                    <td>return_type func(datatype *param)</td>
                </tr>
                <tr>
                    <td><strong>Access Value</strong></td>
                    <td>Direct access</td>
                    <td>Through dereference (*)</td>
                </tr>
                <tr>
                    <td><strong>Performance</strong></td>
                    <td>Slower for large data</td>
                    <td>Faster (no copying overhead)</td>
                </tr>
                <tr>
                    <td><strong>Use Case</strong></td>
                    <td>When original data should not change</td>
                    <td>When function needs to modify original data</td>
                </tr>
            </table>
        </div>
        
        <div class="section">
            <h2>5. Advanced Examples</h2>
            
            <h3>5.1 Array Processing Example</h3>
            <p>Arrays are always passed by reference in C (array name represents the address of first element):</p>
            
            <div class="code-block">
                <pre>
#include &lt;stdio.h&gt;

void modify_array(int arr[], int size) {
    // Arrays are passed by reference automatically
    for(int i = 0; i &lt; size; i++) {
        arr[i] = arr[i] * 2;  // Modifies original array
    }
}

void display_array(int arr[], int size) {
    for(int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int numbers[] = {1, 2, 3, 4, 5};
    int size = 5;
    
    printf("Original array: ");
    display_array(numbers, size);
    
    modify_array(numbers, size);  // No & needed for arrays
    
    printf("Modified array: ");
    display_array(numbers, size);
    
    return 0;
}
                </pre>
            </div>
            
            <div class="output">
                <strong>Output:</strong><br>
                Original array: 1 2 3 4 5<br>
                Modified array: 2 4 6 8 10
            </div>
            
            <h3>5.2 Multiple Return Values using Call by Reference</h3>
            <div class="code-block">
                <pre>
#include &lt;stdio.h&gt;

// Function to perform multiple operations and return multiple results
void calculate(int a, int b, int *sum, int *diff, int *product) {
    *sum = a + b;
    *diff = a - b;
    *product = a * b;
}

int main() {
    int num1 = 15, num2 = 5;
    int addition, subtraction, multiplication;
    
    printf("Numbers: %d and %d\n", num1, num2);
    
    // Pass addresses to get multiple results
    calculate(num1, num2, &addition, &subtraction, &multiplication);
    
    printf("Sum: %d\n", addition);
    printf("Difference: %d\n", subtraction);
    printf("Product: %d\n", multiplication);
    
    return 0;
}
                </pre>
            </div>
            
            <div class="output">
                <strong>Output:</strong><br>
                Numbers: 15 and 5<br>
                Sum: 20<br>
                Difference: 10<br>
                Product: 75
            </div>
        </div>
        
        <div class="section">
            <h2>6. Common Mistakes and Best Practices</h2>
            
            <div class="highlight">
                <h4>Common Mistakes:</h4>
                <ol>
                    <li><strong>Forgetting to use & operator:</strong> When you want to pass by reference but forget &</li>
                    <li><strong>Incorrect pointer syntax:</strong> Using * when not needed or missing * when dereferencing</li>
                    <li><strong>Assuming call by value will modify original:</strong> Expecting changes in call by value functions</li>
                    <li><strong>Null pointer dereferencing:</strong> Not checking if pointer is valid before using</li>
                </ol>
            </div>
            
            <div class="key-point">
                <h4>Best Practices:</h4>
                <ul>
                    <li>Use call by value when you don't need to modify the original variable</li>
                    <li>Use call by reference when the function needs to modify the original variable</li>
                    <li>Always validate pointers before dereferencing them</li>
                    <li>Use const keyword for parameters that shouldn't be modified</li>
                    <li>Choose meaningful parameter names to indicate their purpose</li>
                </ul>
            </div>
            
            <h3>6.1 Safe Call by Reference with const</h3>
            <div class="code-block">
                <pre>
#include &lt;stdio.h&gt;

// Using const to prevent accidental modification
void print_value(const int *ptr) {
    printf("Value: %d\n", *ptr);
    // *ptr = 100;  // This would cause compilation error due to const
}

// Function that safely modifies the value
void safe_increment(int *ptr) {
    if (ptr != NULL) {  // Always check for null pointer
        (*ptr)++;
    }
}

int main() {
    int x = 42;
    
    print_value(&x);    // Safe - cannot modify x
    safe_increment(&x); // Safe - with null check
    print_value(&x);
    
    return 0;
}
                </pre>
            </div>
        </div>
        
        <div class="exercise">
            <h4>Practice Exercise</h4>
            <p><strong>Problem:</strong> Write a C program that includes the following functions:</p>
            <ol>
                <li>A function to find both maximum and minimum values in an array (use call by reference to return both values)</li>
                <li>A function to calculate the factorial of a number (use call by value)</li>
                <li>A function to reverse an array in-place (use call by reference)</li>
            </ol>
            <p><strong>Hint:</strong> Think about which functions need to modify original data and which ones don't.</p>
        </div>
        
        <div class="summary">
            <h3>Summary</h3>
            <p>In this lecture, we explored the fundamental concepts of parameter passing in C:</p>
            <ul>
                <li><strong>Call by Value:</strong> Passes a copy of the value, original data remains unchanged, safer but uses more memory</li>
                <li><strong>Call by Reference:</strong> Passes the address using pointers, allows modification of original data, more memory efficient</li>
                <li><strong>Arrays</strong> are automatically passed by reference in C</li>
                <li><strong>Pointers</strong> are essential for implementing call by reference</li>
                <li>Choice between methods depends on whether you need to modify the original data</li>
            </ul>
            
            <p><strong>Next Lecture Preview:</strong> We will explore advanced pointer concepts and dynamic memory allocation.</p>
        </div>
        
        <div class="footer">
            <p>End of Lecture 15 | Unit III: Array and Function</p>
            <p>C Programming | BTech First Semester | UPES</p>
        </div>
    </div>
</body>
</html>