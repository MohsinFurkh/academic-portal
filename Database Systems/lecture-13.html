<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lecture 13: File Organization and Indexing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .presentation {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .slide {
            background: white;
            border-radius: 15px;
            padding: 50px;
            margin-bottom: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .slide-header {
            border-bottom: 4px solid #667eea;
            padding-bottom: 15px;
            margin-bottom: 30px;
        }
        
        .slide-number {
            color: #667eea;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        h1 {
            color: #2d3748;
            font-size: 42px;
            margin-bottom: 10px;
            line-height: 1.2;
        }
        
        h2 {
            color: #667eea;
            font-size: 32px;
            margin-bottom: 20px;
            margin-top: 30px;
        }
        
        h3 {
            color: #4a5568;
            font-size: 24px;
            margin-bottom: 15px;
            margin-top: 25px;
        }
        
        p {
            color: #4a5568;
            font-size: 18px;
            line-height: 1.8;
            margin-bottom: 15px;
        }
        
        .university-info {
            text-align: center;
            color: #718096;
            font-size: 16px;
            margin-top: 20px;
        }
        
        .instructor {
            color: #667eea;
            font-weight: 600;
            margin-top: 10px;
        }
        
        .content-box {
            background: #f7fafc;
            border-left: 5px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .key-point {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
            border: 2px solid #667eea;
        }
        
        .definition {
            background: #edf2f7;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border-left: 5px solid #48bb78;
        }
        
        .example-box {
            background: #fffaf0;
            padding: 25px;
            margin: 25px 0;
            border-radius: 10px;
            border: 2px solid #ed8936;
        }
        
        .formula {
            background: #2d3748;
            color: #fff;
            padding: 15px 20px;
            margin: 15px 0;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            overflow-x: auto;
        }
        
        .calculation {
            background: #e6fffa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 4px solid #38b2ac;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        td {
            padding: 15px;
            border-bottom: 1px solid #e2e8f0;
            color: #4a5568;
        }
        
        tr:hover {
            background: #f7fafc;
        }
        
        .advantage {
            color: #48bb78;
            font-weight: 600;
        }
        
        .disadvantage {
            color: #f56565;
            font-weight: 600;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-bottom: 20px;
        }
        
        li {
            color: #4a5568;
            font-size: 18px;
            line-height: 1.8;
            margin-bottom: 10px;
        }
        
        .highlight {
            background: #fef5e7;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: #d97706;
        }
        
        .diagram {
            background: white;
            border: 2px solid #cbd5e0;
            border-radius: 10px;
            padding: 30px;
            margin: 30px 0;
            text-align: center;
        }
        
        .box {
            display: inline-block;
            padding: 15px 30px;
            border: 2px solid #667eea;
            border-radius: 8px;
            margin: 10px;
            background: #f7fafc;
        }
        
        .arrow {
            display: inline-block;
            margin: 0 10px;
            color: #667eea;
            font-size: 24px;
        }
        
        @media print {
            body {
                background: white;
            }
            .slide {
                page-break-after: always;
                box-shadow: none;
            }
        }
    </style>
</head>
<body>
    <div class="presentation">
        
        <!-- Title Slide -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Lecture 13</div>
            </div>
            <h1>File Organization and Indexing</h1>
            <p style="font-size: 24px; color: #667eea; margin-top: 20px;">Unit III: Storage & Indexing</p>
            <div class="university-info">
                <p><strong>Database Systems - MTech First Semester</strong></p>
                <p>Cloud & Software Operations Cluster | SOCS | UPES</p>
                <p class="instructor">Dr. Mohsin Dar<br>Assistant Professor</p>
            </div>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Learning Objectives</div>
            </div>
            <h2>What We'll Learn Today</h2>
            <div class="content-box">
                <ul>
                    <li>Understand different file organization techniques</li>
                    <li>Learn the concept and importance of indexing</li>
                    <li>Explore various types of indexes</li>
                    <li>Analyze index performance through practical calculations</li>
                    <li>Compare different file organization methods</li>
                </ul>
            </div>
        </div>

        <!-- Slide 3: Introduction to File Organization -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">File Organization</div>
            </div>
            <h2>What is File Organization?</h2>
            <div class="definition">
                <p><strong>File Organization</strong> refers to the way records are arranged and stored in a file on secondary storage devices.</p>
            </div>
            <p>The organization of data files impacts:</p>
            <ul>
                <li><strong>Access Time:</strong> How quickly we can retrieve records</li>
                <li><strong>Storage Efficiency:</strong> How much space is utilized</li>
                <li><strong>Update Performance:</strong> Speed of insertions, deletions, and modifications</li>
                <li><strong>Query Performance:</strong> How efficiently we can search for data</li>
            </ul>
        </div>

        <!-- Slide 4: Types of File Organization -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">File Organization Types</div>
            </div>
            <h2>Types of File Organization</h2>
            
            <h3>1. Heap File (Unordered)</h3>
            <p>Records are stored in the order they are inserted - no particular ordering.</p>
            
            <div class="definition">
                <h3>Unordered File Organization Details</h3>
                <ul>
                    <li>Records are typically added at the end of the file, without following any specific order.</li>
                    <li>This insertion method allows only linear search, resulting in slower search times.</li>
                    <li>Despite slow searches, maintenance including insertion and deletion is simpler.</li>
                    <li>No reorganization of the entire file is needed, making maintenance easier.</li>
                    <li>If file is unordered, number of block accesses required to reach correct block which contains the desired record is <strong>O(n)</strong>, where n is the number of blocks.</li>
                </ul>
            </div>

            <div class="diagram">
                <h3>Unordered File Organization Example</h3>
                <img src="file_org_unordered.png" alt="Unordered File Organization" style="max-width: 100%; height: auto; border: 2px solid #cbd5e0; border-radius: 8px; margin: 20px 0;">
            </div>

            <div class="content-box">
                <p><span class="advantage">✓ Advantages:</span> Fast insertion (O(1)), simple structure, no reorganization needed</p>
                <p><span class="disadvantage">✗ Disadvantages:</span> Slow search (O(n) - linear scan), inefficient for queries</p>
            </div>

            <h3>2. Sequential File (Ordered)</h3>
            <p>Records are stored in order based on a key field.</p>
            
            <div class="definition">
                <h3>Ordered File Organization Details</h3>
                <ul>
                    <li>All the records in the file are ordered on some search key field.</li>
                    <li>Here binary search is possible. <em>(Similar to searching for a page in a book - you can jump to the middle, then decide whether to go forward or backward, significantly reducing search time)</em></li>
                    <li>Maintenance (insertion & deletion) is costly, as it requires reorganization of entire file.</li>
                    <li><strong>Important Note:</strong> We will get binary search only if we are using that key for searching on which indexing is done, otherwise it will behave as unsorted file.</li>
                    <li>If file is ordered, number of block accesses required to reach correct block which contains the desired record is <strong>O(log<sub>2</sub>n)</strong>, where n is the number of blocks.</li>
                </ul>
            </div>

            <div class="diagram">
                <h3>Ordered File Organization Example</h3>
                <img src="file_org_ordered.png" alt="Ordered File Organization" style="max-width: 100%; height: auto; border: 2px solid #cbd5e0; border-radius: 8px; margin: 20px 0;">
            </div>

            <div class="content-box">
                <p><span class="advantage">✓ Advantages:</span> Efficient for range queries, binary search possible (O(log<sub>2</sub>n))</p>
                <p><span class="disadvantage">✗ Disadvantages:</span> Expensive insertions/deletions, requires reorganization</p>
            </div>

            <h3>3. Hash File</h3>
            <p>Records are distributed across buckets using a hash function.</p>
            <div class="content-box">
                <p><span class="advantage">✓ Advantages:</span> Fast exact-match queries</p>
                <p><span class="disadvantage">✗ Disadvantages:</span> Poor for range queries, collisions</p>
            </div>
        </div>

        <!-- Slide 5: File Organization Comparison -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Comparison</div>
            </div>
            <h2>File Organization Comparison</h2>
            <table>
                <tr>
                    <th>Organization</th>
                    <th>Search</th>
                    <th>Insert</th>
                    <th>Delete</th>
                    <th>Range Query</th>
                </tr>
                <tr>
                    <td><strong>Heap</strong></td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><strong>Sequential</strong></td>
                    <td>O(log n)</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>Efficient</td>
                </tr>
                <tr>
                    <td><strong>Hash</strong></td>
                    <td>O(1) avg</td>
                    <td>O(1) avg</td>
                    <td>O(1) avg</td>
                    <td>Poor</td>
                </tr>
            </table>
        </div>

        <!-- Slide 6: Need for Indexing -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Indexing Motivation</div>
            </div>
            <h2>Why Do We Need Indexing?</h2>
            
            <div class="content-box">
                <h3>Foundation: Relational Databases and Set Theory</h3>
                <ul>
                    <li>Relational databases are based on set theory.</li>
                    <li>In set theory, the order of elements is unimportant, similarly in database tables.</li>
                    <li>However, in practical implementation, element order in tables is often specified.</li>
                    <li>Various operations such as search, insertion, and deletion are influenced by the order of elements in the tables.</li>
                    <li>Elements in a table can be stored in two ways: <strong>sorted (ordered)</strong> or <strong>unsorted (unordered)</strong>.</li>
                </ul>
            </div>

            <div class="key-point">
                <p><strong>Problem:</strong> Searching through millions of records sequentially is extremely slow!</p>
            </div>
            
            <p>Consider a database with 1 million records:</p>
            <ul>
                <li><strong>Without Index:</strong> Average 500,000 record accesses</li>
                <li><strong>With Index:</strong> Approximately 20 record accesses (using B+ tree)</li>
            </ul>

            <div class="content-box">
                <h3>Real-World Analogy</h3>
                <p>An index in a database is like an index in a book:</p>
                <ul>
                    <li>Book index: Find page numbers quickly without reading entire book</li>
                    <li>Database index: Find records quickly without scanning entire file</li>
                </ul>
            </div>

            <div class="diagram">
                <h3>Example: Book Index</h3>
                <img src="index_example.png" alt="Book Index Example" style="max-width: 100%; height: auto; border: 2px solid #cbd5e0; border-radius: 8px; margin: 20px 0;">
                <p style="color: #4a5568; font-style: italic; margin-top: 10px;">Just like a book's index helps you find topics quickly, a database index helps locate records efficiently.</p>
            </div>
        </div>

        <!-- Slide 7: What is an Index -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Index Definition</div>
            </div>
            <h2>What is an Index?</h2>
            <div class="definition">
                <p><strong>Index:</strong> A data structure that improves the speed of data retrieval operations on a database table at the cost of additional storage space and slower writes.</p>
            </div>

            <h3>Index Structure</h3>
            <p>An index consists of:</p>
            <ul>
                <li><strong>Search Key:</strong> Attribute(s) used to look up records</li>
                <li><strong>Data Pointer:</strong> Reference to the actual data record location</li>
            </ul>

            <div class="diagram">
                <div class="box">Search Key Value</div>
                <span class="arrow">→</span>
                <div class="box">Pointer to Record</div>
            </div>
        </div>

        <!-- Slide 8: Types of Indexes -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Index Classification</div>
            </div>
            <h2>Types of Indexes</h2>

            <h3>Based on File Organization:</h3>
            <div class="content-box">
                <p><strong>1. Primary Index</strong></p>
                <p>Built on the ordering key field of an ordered file. One index entry per data block.</p>
            </div>

            <div class="content-box">
                <p><strong>2. Clustering Index</strong></p>
                <p>Built on non-key ordering field. Multiple records may have the same value.</p>
            </div>

            <div class="content-box">
                <p><strong>3. Secondary Index</strong></p>
                <p>Built on any non-ordering field. Can be on key or non-key fields.</p>
            </div>
        </div>

        <!-- Slide 9: Primary Index Details -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Primary Index</div>
            </div>
            <h2>Primary Index in Detail</h2>
            
            <div class="key-point">
                <p><strong>Primary Index:</strong> A sparse index on the ordering key field of a sequentially ordered file.</p>
            </div>

            <h3>Characteristics:</h3>
            <ul>
                <li>Data file must be ordered on a key field</li>
                <li>One index entry for each <strong>block</strong> (not each record)</li>
                <li>Index entry = (Key value of first record in block, Pointer to block)</li>
                <li>Significantly smaller than data file</li>
                <li>Enables binary search on blocks</li>
            </ul>

            <h3>Structure:</h3>
            <table>
                <tr>
                    <th>Index Entry</th>
                    <th>Components</th>
                </tr>
                <tr>
                    <td>K(i)</td>
                    <td>Key value of first record in block i</td>
                </tr>
                <tr>
                    <td>P(i)</td>
                    <td>Pointer to block i</td>
                </tr>
            </table>
        </div>

        <!-- Slide 10: Primary Index Example Problem -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Practical Example</div>
            </div>
            <h2>Primary Index: Problem Statement</h2>
            <div class="example-box">
                <h3>Given:</h3>
                <ul>
                    <li>Number of records: <strong>r = 30,000</strong></li>
                    <li>Block size: <strong>B = 1,024 bytes</strong></li>
                    <li>Record length: <strong>R = 100 bytes</strong></li>
                    <li>Ordering key field length: <strong>V = 9 bytes</strong></li>
                    <li>Block pointer size: <strong>P = 6 bytes</strong></li>
                    <li>Records are fixed-size and unspanned</li>
                </ul>
                <h3>Find:</h3>
                <p>Design and analyze the primary index for this file.</p>
            </div>
        </div>

        <!-- Slide 11: Solution Step 1 -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Solution - Part 1</div>
            </div>
            <h2>Step 1: Calculate Blocking Factor (bfr)</h2>
            
            <p><strong>Blocking Factor (bfr):</strong> Number of records that can fit in one block</p>
            
            <div class="formula">
                bfr = ⌊Block Size / Record Size⌋ = ⌊B / R⌋
            </div>

            <div class="calculation">
                <p><strong>Calculation:</strong></p>
                <p>bfr = ⌊1,024 / 100⌋ = ⌊10.24⌋ = <span class="highlight">10 records/block</span></p>
            </div>

            <p><strong>Interpretation:</strong> Each data block can store exactly 10 records. The remaining 24 bytes in each block are wasted (internal fragmentation).</p>
        </div>

        <!-- Slide 12: Solution Step 2 -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Solution - Part 2</div>
            </div>
            <h2>Step 2: Calculate Number of Blocks (b)</h2>
            
            <p><strong>Number of Blocks:</strong> Total blocks needed to store all records</p>
            
            <div class="formula">
                b = ⌈Total Records / Blocking Factor⌉ = ⌈r / bfr⌉
            </div>

            <div class="calculation">
                <p><strong>Calculation:</strong></p>
                <p>b = ⌈30,000 / 10⌉ = <span class="highlight">3,000 blocks</span></p>
            </div>

            <p><strong>Storage for Data File:</strong></p>
            <div class="calculation">
                <p>Total Space = 3,000 blocks × 1,024 bytes = 3,072,000 bytes ≈ 3 MB</p>
            </div>
        </div>

        <!-- Slide 13: Solution Step 3 -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Solution - Part 3</div>
            </div>
            <h2>Step 3: Calculate Index Entry Size</h2>
            
            <p><strong>Index Entry Components:</strong></p>
            <ul>
                <li>Search Key Value: V = 9 bytes</li>
                <li>Block Pointer: P = 6 bytes</li>
            </ul>

            <div class="formula">
                Index Entry Size = V + P
            </div>

            <div class="calculation">
                <p><strong>Calculation:</strong></p>
                <p>Index Entry Size = 9 + 6 = <span class="highlight">15 bytes</span></p>
            </div>

            <p>Each index entry will store:</p>
            <div class="content-box">
                <p>[ Key of First Record | Block Pointer ]</p>
                <p>[ 9 bytes | 6 bytes ] = 15 bytes total</p>
            </div>
        </div>

        <!-- Slide 14: Solution Step 4 -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Solution - Part 4</div>
            </div>
            <h2>Step 4: Calculate Index Blocking Factor (bfr<sub>i</sub>)</h2>
            
            <p><strong>Index Blocking Factor:</strong> Number of index entries per block</p>
            
            <div class="formula">
                bfr<sub>i</sub> = ⌊Block Size / Index Entry Size⌋ = ⌊B / (V + P)⌋
            </div>

            <div class="calculation">
                <p><strong>Calculation:</strong></p>
                <p>bfr<sub>i</sub> = ⌊1,024 / 15⌋ = ⌊68.27⌋ = <span class="highlight">68 entries/block</span></p>
            </div>

            <p><strong>Interpretation:</strong> Each index block can store 68 index entries.</p>
            <div class="calculation">
                <p>Utilized space per index block: 68 × 15 = 1,020 bytes</p>
                <p>Wasted space per index block: 1,024 - 1,020 = 4 bytes</p>
            </div>
        </div>

        <!-- Slide 15: Solution Step 5 -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Solution - Part 5</div>
            </div>
            <h2>Step 5: Calculate Number of Index Blocks (b<sub>i</sub>)</h2>
            
            <p><strong>Number of Index Entries:</strong> One entry per data block = 3,000 entries</p>
            
            <div class="formula">
                b<sub>i</sub> = ⌈Number of Index Entries / bfr<sub>i</sub>⌉ = ⌈b / bfr<sub>i</sub>⌉
            </div>

            <div class="calculation">
                <p><strong>Calculation:</strong></p>
                <p>b<sub>i</sub> = ⌈3,000 / 68⌉ = ⌈44.12⌉ = <span class="highlight">45 index blocks</span></p>
            </div>

            <p><strong>Storage for Index File:</strong></p>
            <div class="calculation">
                <p>Index Space = 45 blocks × 1,024 bytes = 46,080 bytes ≈ 45 KB</p>
            </div>
        </div>

        <!-- Slide 16: Performance Analysis -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Performance Analysis</div>
            </div>
            <h2>Search Performance Comparison</h2>

            <h3>Without Primary Index (Linear Search):</h3>
            <div class="calculation">
                <p><strong>Average block accesses:</strong> b / 2 = 3,000 / 2 = <span class="highlight">1,500 blocks</span></p>
                <p><strong>Worst case:</strong> 3,000 blocks</p>
            </div>

            <h3>With Primary Index (Binary Search on Index):</h3>
            <div class="calculation">
                <p><strong>Index search:</strong> ⌈log<sub>2</sub>(45)⌉ = <span class="highlight">6 block accesses</span></p>
                <p><strong>Data block access:</strong> 1 block access</p>
                <p><strong>Total:</strong> 6 + 1 = <span class="highlight">7 block accesses</span></p>
            </div>

            <div class="key-point">
                <h3>Performance Improvement</h3>
                <p>Speedup: 1,500 / 7 = <strong>214× faster on average!</strong></p>
            </div>
        </div>

        <!-- Slide 17: Index Space Overhead -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Space Analysis</div>
            </div>
            <h2>Storage Space Analysis</h2>

            <table>
                <tr>
                    <th>Component</th>
                    <th>Size</th>
                    <th>Percentage</th>
                </tr>
                <tr>
                    <td>Data File</td>
                    <td>3,072,000 bytes (≈3 MB)</td>
                    <td>98.5%</td>
                </tr>
                <tr>
                    <td>Primary Index</td>
                    <td>46,080 bytes (≈45 KB)</td>
                    <td>1.5%</td>
                </tr>
                <tr>
                    <td><strong>Total</strong></td>
                    <td><strong>3,118,080 bytes</strong></td>
                    <td><strong>100%</strong></td>
                </tr>
            </table>

            <div class="key-point">
                <p><strong>Key Insight:</strong> The index uses only 1.5% additional space but provides 214× performance improvement for searches!</p>
            </div>

            <div class="content-box">
                <p><strong>Space-Performance Tradeoff:</strong> This is an excellent tradeoff - minimal space overhead for massive performance gains.</p>
            </div>
        </div>

        <!-- Slide 18: Index Characteristics Summary -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Index Properties</div>
            </div>
            <h2>Primary Index Characteristics</h2>

            <h3>Advantages:</h3>
            <ul>
                <li>✓ Dramatically faster search operations</li>
                <li>✓ Small storage overhead (sparse index)</li>
                <li>✓ Efficient for range queries on ordering key</li>
                <li>✓ Binary search possible on index</li>
            </ul>

            <h3>Disadvantages:</h3>
            <ul>
                <li>✗ Data file must remain sorted</li>
                <li>✗ Insertions/deletions are expensive (require reorganization)</li>
                <li>✗ Only one primary index per file (on ordering key)</li>
                <li>✗ Index must be updated when data changes</li>
            </ul>
        </div>

        <!-- Slide 19: Dense vs Sparse Indexes -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Index Density</div>
            </div>
            <h2>Dense vs Sparse Indexes</h2>

            <div class="content-box">
                <h3>Dense Index</h3>
                <p>Contains an index entry for <strong>every search key value</strong> in the data file.</p>
                <ul>
                    <li>One entry per record</li>
                    <li>Larger space requirement</li>
                    <li>Can determine record existence from index alone</li>
                </ul>
            </div>

            <div class="content-box">
                <h3>Sparse Index</h3>
                <p>Contains index entries for only <strong>some of the search key values</strong>.</p>
                <ul>
                    <li>One entry per block (like primary index)</li>
                    <li>Smaller space requirement</li>
                    <li>Data file must be ordered</li>
                    <li>Our example uses a sparse index!</li>
                </ul>
            </div>
        </div>

        <!-- Slide 20: Practical Considerations -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Implementation Notes</div>
            </div>
            <h2>Practical Implementation Considerations</h2>

            <h3>When to Use Primary Index:</h3>
            <ul>
                <li>Data is naturally ordered (e.g., employee IDs, timestamps)</li>
                <li>Frequent searches on the ordering key</li>
                <li>Range queries are common</li>
                <li>Insert/update frequency is low to moderate</li>
            </ul>

            <h3>Maintenance Considerations:</h3>
            <ul>
                <li><strong>Insertion:</strong> May require reorganization if no space in block</li>
                <li><strong>Deletion:</strong> May leave blocks underutilized</li>
                <li><strong>Updates:</strong> If key changes, may need reorganization</li>
                <li><strong>Periodic Reorganization:</strong> Needed to maintain efficiency</li>
            </ul>
        </div>

        <!-- Slide 21: Summary -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Summary</div>
            </div>
            <h2>Key Takeaways</h2>

            <div class="key-point">
                <ul>
                    <li>File organization determines how records are physically stored</li>
                    <li>Indexes are auxiliary structures that speed up data retrieval</li>
                    <li>Primary index is a sparse index on an ordered file's key field</li>
                    <li>Primary index provides massive performance gains with minimal space overhead</li>
                    <li>Trade-off: faster searches vs. slower updates</li>
                </ul>
            </div>

            <h3>In Our Example:</h3>
            <div class="calculation">
                <p>• 30,000 records → 3,000 data blocks</p>
                <p>• Primary index → 45 index blocks</p>
                <p>• Search improvement: 1,500 accesses → 7 accesses (214× faster)</p>
                <p>• Space overhead: Only 1.5% additional storage</p>
            </div>
        </div>

        <!-- Slide 22: Index Operations -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Index Operations</div>
            </div>
            <h2>Operations on Primary Index</h2>

            <h3>1. Search Operation</h3>
            <div class="content-box">
                <p><strong>Algorithm:</strong></p>
                <ol>
                    <li>Perform binary search on index file to find appropriate index entry</li>
                    <li>Follow block pointer to data block</li>
                    <li>Search within the block for the record</li>
                </ol>
                <p><strong>Time Complexity:</strong> O(log<sub>2</sub> b<sub>i</sub>) + 1 block accesses</p>
            </div>

            <h3>2. Insertion Operation</h3>
            <div class="content-box">
                <p><strong>Algorithm:</strong></p>
                <ol>
                    <li>Find appropriate block using index</li>
                    <li>If block has space, insert record maintaining order</li>
                    <li>If block is full, reorganize (overflow handling)</li>
                    <li>Update index if first record of block changes</li>
                </ol>
                <p><strong>Challenge:</strong> May require data reorganization</p>
            </div>

            <h3>3. Deletion Operation</h3>
            <div class="content-box">
                <p><strong>Algorithm:</strong></p>
                <ol>
                    <li>Find record using index</li>
                    <li>Delete record from data block</li>
                    <li>Update index if first record of block was deleted</li>
                    <li>Handle underflow if necessary</li>
                </ol>
            </div>
        </div>

        <!-- Slide 23: Example Walkthrough -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Search Example</div>
            </div>
            <h2>Example: Searching for a Record</h2>

            <div class="example-box">
                <p><strong>Scenario:</strong> Search for employee with ID = 15,750</p>
                
                <h3>Step 1: Binary Search in Index</h3>
                <div class="calculation">
                    <p>Index has 45 blocks with 68 entries each</p>
                    <p>Binary search iterations: ⌈log<sub>2</sub>(45)⌉ = 6 accesses</p>
                    <p>Find: Index entry with key ≤ 15,750</p>
                </div>

                <h3>Step 2: Access Data Block</h3>
                <div class="calculation">
                    <p>Follow pointer from index to data block</p>
                    <p>Block contains records starting with key 15,741</p>
                    <p>1 block access</p>
                </div>

                <h3>Step 3: Search Within Block</h3>
                <div class="calculation">
                    <p>Block has 10 records (bfr = 10)</p>
                    <p>Can use binary search or linear scan</p>
                    <p>Find employee record with ID = 15,750</p>
                </div>

                <p><strong>Total: 7 block accesses</strong> vs 1,500 average without index!</p>
            </div>
        </div>

        <!-- Slide 24: Multilevel Indexes Preview -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Looking Ahead</div>
            </div>
            <h2>What if the Index Becomes Too Large?</h2>

            <div class="key-point">
                <p><strong>Problem:</strong> If the index itself becomes very large (doesn't fit in memory), we need multiple disk accesses to search the index!</p>
            </div>

            <h3>Solution: Multilevel Indexes</h3>
            <p>Create an index on the index!</p>
            
            <div class="diagram">
                <div style="margin: 20px;">
                    <div class="box">Level 2 Index<br>(Index on Index)</div>
                    <div style="margin: 10px 0;">↓</div>
                    <div class="box">Level 1 Index<br>(Primary Index)</div>
                    <div style="margin: 10px 0;">↓</div>
                    <div class="box">Data File<br>(Actual Records)</div>
                </div>
            </div>

            <p><strong>Preview:</strong> We'll study B-Trees and B+ Trees in upcoming lectures - these are sophisticated multilevel index structures!</p>
        </div>

        <!-- Slide 25: Index Design Guidelines -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Design Guidelines</div>
            </div>
            <h2>Guidelines for Index Design</h2>

            <h3>Choose Primary Index When:</h3>
            <ul>
                <li>✓ Data has a natural ordering key</li>
                <li>✓ Frequent searches on that key field</li>
                <li>✓ Range queries are important</li>
                <li>✓ Updates are infrequent or can be batched</li>
            </ul>

            <h3>Avoid Primary Index When:</h3>
            <ul>
                <li>✗ Data changes very frequently</li>
                <li>✗ Random access patterns dominate</li>
                <li>✗ No clear ordering key exists</li>
                <li>✗ Point queries only (consider hash-based indexing)</li>
            </ul>

            <div class="content-box">
                <p><strong>Best Practice:</strong> Analyze your query patterns and update frequencies before choosing an indexing strategy!</p>
            </div>
        </div>

        <!-- Slide 26: Real-World Applications -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Applications</div>
            </div>
            <h2>Real-World Applications</h2>

            <h3>Primary Indexes are Used In:</h3>
            
            <div class="content-box">
                <h4>1. Employee Management Systems</h4>
                <p>Ordered by Employee ID - natural ordering key for HR queries</p>
            </div>

            <div class="content-box">
                <h4>2. Financial Transactions</h4>
                <p>Ordered by Transaction ID or Timestamp - audit trails and reporting</p>
            </div>

            <div class="content-box">
                <h4>3. Student Information Systems</h4>
                <p>Ordered by Student ID - academic records and enrollment</p>
            </div>

            <div class="content-box">
                <h4>4. Inventory Management</h4>
                <p>Ordered by Product ID - stock tracking and ordering</p>
            </div>

            <div class="content-box">
                <h4>5. Log File Analysis</h4>
                <p>Ordered by Timestamp - chronological event tracking</p>
            </div>
        </div>

        <!-- Slide 27: Common Pitfalls -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Common Mistakes</div>
            </div>
            <h2>Common Pitfalls to Avoid</h2>

            <div class="content-box" style="border-left-color: #f56565;">
                <h3>❌ Mistake 1: Creating Index on Unsorted Data</h3>
                <p>Primary index requires ordered data file. Random order won't work!</p>
            </div>

            <div class="content-box" style="border-left-color: #f56565;">
                <h3>❌ Mistake 2: Using Wrong Pointer Size</h3>
                <p>Block pointer size affects index entry size calculations. Use system-specific values.</p>
            </div>

            <div class="content-box" style="border-left-color: #f56565;">
                <h3>❌ Mistake 3: Forgetting Index Maintenance</h3>
                <p>Insertions and deletions require index updates. Plan for maintenance overhead.</p>
            </div>

            <div class="content-box" style="border-left-color: #f56565;">
                <h3>❌ Mistake 4: Ignoring Block Boundaries</h3>
                <p>Always use floor function for blocking factors - partial records don't fit!</p>
            </div>

            <div class="content-box" style="border-left-color: #f56565;">
                <h3>❌ Mistake 5: Multiple Primary Indexes</h3>
                <p>Only ONE primary index per file (on ordering key). Use secondary indexes for other fields.</p>
            </div>
        </div>

        <!-- Slide 28: Calculation Formulas Summary -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Formula Reference</div>
            </div>
            <h2>Key Formulas for Primary Index</h2>

            <div class="formula">
1. Blocking Factor (Data):
   bfr = ⌊Block Size / Record Size⌋ = ⌊B / R⌋
            </div>

            <div class="formula">
2. Number of Data Blocks:
   b = ⌈Total Records / bfr⌉ = ⌈r / bfr⌉
            </div>

            <div class="formula">
3. Index Entry Size:
   Entry Size = Key Field Size + Pointer Size = V + P
            </div>

            <div class="formula">
4. Index Blocking Factor:
   bfr_i = ⌊B / (V + P)⌋
            </div>

            <div class="formula">
5. Number of Index Blocks:
   b_i = ⌈Number of Data Blocks / bfr_i⌉ = ⌈b / bfr_i⌉
            </div>

            <div class="formula">
6. Search Cost (with index):
   Cost = ⌈log₂(b_i)⌉ + 1 block accesses
            </div>
        </div>

        <!-- Slide 29: Practice Problem -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Practice Problem</div>
            </div>
            <h2>Try This Yourself!</h2>

            <div class="example-box">
                <h3>Problem:</h3>
                <p>A university database has the following specifications:</p>
                <ul>
                    <li>Total student records: <strong>50,000</strong></li>
                    <li>Block size: <strong>2,048 bytes</strong></li>
                    <li>Student record size: <strong>128 bytes</strong></li>
                    <li>Student ID (key) size: <strong>8 bytes</strong></li>
                    <li>Block pointer size: <strong>8 bytes</strong></li>
                </ul>

                <h3>Calculate:</h3>
                <ol>
                    <li>Blocking factor for data file</li>
                    <li>Number of data blocks required</li>
                    <li>Index blocking factor</li>
                    <li>Number of index blocks required</li>
                    <li>Search cost with and without index</li>
                    <li>Space overhead of the index</li>
                </ol>

                <p><strong>Hint:</strong> Follow the same steps as our worked example!</p>
            </div>
        </div>

        <!-- Slide 30: Next Lecture Preview -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Next Lecture</div>
            </div>
            <h2>Looking Ahead: Lecture 19</h2>

            <h3>Topics to be Covered:</h3>
            <ul>
                <li><strong>Clustering Indexes</strong> - For non-key ordering fields</li>
                <li><strong>Secondary Indexes</strong> - On non-ordering fields</li>
                <li>Comparison of different index types</li>
                <li>When to use each type of index</li>
                <li>Dense vs Sparse indexes in detail</li>
            </ul>

            <div class="key-point">
                <p><strong>Prepare for Next Class:</strong> Review primary index concepts and practice the calculation problems!</p>
            </div>
        </div>

        <!-- Slide 31: Questions & Discussion -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">Q&A</div>
            </div>
            <h2>Questions & Discussion</h2>
            
            <div class="content-box">
                <h3>Key Discussion Points:</h3>
                <ul>
                    <li>How does primary index improve database performance?</li>
                    <li>What are the trade-offs of using indexes?</li>
                    <li>When would you avoid using a primary index?</li>
                    <li>How does sparse indexing save space?</li>
                </ul>
            </div>

            <div style="text-align: center; margin-top: 50px;">
                <h2 style="color: #667eea;">Thank You!</h2>
                <p style="font-size: 20px; color: #718096; margin-top: 20px;">
                    Dr. Mohsin Dar<br>
                    Cloud & Software Operations Cluster<br>
                    UPES
                </p>
            </div>
        </div>

        <!-- Slide 32: References -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-number">References</div>
            </div>
            <h2>Recommended Reading</h2>

            <div class="content-box">
                <h3>Textbooks:</h3>
                <ul>
                    <li>"Fundamentals of Database Systems" by Elmasri & Navathe (Chapter 17)</li>
                    <li>"Database System Concepts" by Silberschatz, Korth & Sudarshan (Chapter 11)</li>
                    <li>"Database Management Systems" by Raghu Ramakrishnan (Chapter 8)</li>
                </ul>
            </div>

            <div class="content-box">
                <h3>Additional Resources:</h3>
                <ul>
                    <li>Research papers on indexing techniques</li>
                    <li>Database vendor documentation (MySQL, PostgreSQL, Oracle)</li>
                    <li>Online tutorials and visualization tools</li>
                </ul>
            </div>
        </div>

    </div>

    <script>
        // Add smooth scrolling
        document.addEventListener('DOMContentLoaded', function() {
            // Print functionality
            document.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
                    e.preventDefault();
                    window.print();
                }
            });

            // Slide navigation with arrow keys
            let currentSlide = 0;
            const slides = document.querySelectorAll('.slide');
            
            function scrollToSlide(index) {
                if (index >= 0 && index < slides.length) {
                    slides[index].scrollIntoView({ behavior: 'smooth', block: 'start' });
                    currentSlide = index;
                }
            }

            document.addEventListener('keydown', function(e) {
                if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    scrollToSlide(currentSlide + 1);
                } else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
                    e.preventDefault();
                    scrollToSlide(currentSlide - 1);
                } else if (e.key === 'Home') {
                    e.preventDefault();
                    scrollToSlide(0);
                } else if (e.key === 'End') {
                    e.preventDefault();
                    scrollToSlide(slides.length - 1);
                }
            });

            // Update current slide based on scroll position
            window.addEventListener('scroll', function() {
                slides.forEach((slide, index) => {
                    const rect = slide.getBoundingClientRect();
                    if (rect.top >= 0 && rect.top < window.innerHeight / 2) {
                        currentSlide = index;
                    }
                });
            });
        });
    </script>
</body>
</html>