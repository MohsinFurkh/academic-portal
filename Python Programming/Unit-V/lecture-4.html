<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit-V: Polymorphism in Python</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        body { background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); color: #333; line-height: 1.6; }
        .lecture-container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { background: rgba(255,255,255,0.95); padding: 30px; border-radius: 15px; text-align: center; margin-bottom: 30px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
        .header h1 { color: #2a5298; margin-bottom: 10px; }
        .header p { color: #666; font-size: 1.1em; }
        .section { background: white; border-radius: 15px; padding: 25px; margin-bottom: 30px; box-shadow: 0 5px 15px rgba(0,0,0,0.05); }
        .section-header { font-size: 1.5em; color: #1e3c72; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 2px solid #f0f0f0; }
        .code-block { background: #f8f9fa; border-left: 4px solid #1e3c72; padding: 15px; margin: 15px 0; font-family: 'Courier New', monospace; overflow-x: auto; position: relative; }
        .copy-btn { position: absolute; top: 5px; right: 5px; background: #e0e0e0; border: none; border-radius: 3px; padding: 2px 5px; cursor: pointer; }
        .note { background: #e7f4ff; border-left: 4px solid #1e88e5; padding: 15px; margin: 15px 0; border-radius: 0 5px 5px 0; }
        .warning { background: #fff3e0; border-left: 4px solid #ff9800; padding: 15px; margin: 15px 0; border-radius: 0 5px 5px 0; }
        .success { background: #e8f5e9; border-left: 4px solid #4caf50; padding: 15px; margin: 15px 0; border-radius: 0 5px 5px 0; }
        .navigation { display: flex; justify-content: space-between; margin-top: 30px; }
        .btn { background: #1e3c72; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; text-decoration: none; display: inline-block; margin: 5px; }
        .btn:hover { background: #2a5298; }
        .tabs { display: flex; margin-bottom: -1px; flex-wrap: wrap; }
        .tab { padding: 10px 15px; background: #f1f1f1; border: 1px solid #ddd; border-bottom: none; cursor: pointer; border-radius: 5px 5px 0 0; margin-right: 5px; margin-bottom: 5px; }
        .tab.active { background: white; border-bottom: 1px solid white; }
        .tab-content { display: none; padding: 15px; border: 1px solid #ddd; border-radius: 0 0 5px 5px; background: white; margin-bottom: 20px; }
        .tab-content.active { display: block; }
        .method-table { width: 100%; border-collapse: collapse; margin: 15px 0; }
        .method-table th, .method-table td { border: 1px solid #dee2e6; padding: 12px; text-align: left; }
        .method-table th { background-color: #f8f9fa; font-weight: 600; }
        .method-table tr:nth-child(even) { background-color: #f9f9f9; }
        .method-table code { background: #f1f1f1; padding: 2px 5px; border-radius: 3px; font-family: 'Courier New', monospace; }
        @media (max-width: 768px) { 
            .lecture-container { padding: 10px; } 
            .header { padding: 20px 15px; } 
            .section { padding: 15px; }
            .tabs { flex-direction: column; }
            .tab { border-radius: 0; margin-right: 0; border-bottom: 1px solid #ddd; width: 100%; text-align: left; }
            .tab:first-child { border-radius: 5px 5px 0 0; }
            .tab.active { border-bottom: 1px solid white; }
            .method-table { display: block; overflow-x: auto; white-space: nowrap; }
        }
    </style>
</head>
<body>
    <div class="lecture-container">
        <!-- Header Section -->
        <div class="header">
            <h1>üîÑ Unit-V: Advanced OOP in Python</h1>
            <p>Lecture 4: Polymorphism - Function Overriding and Operator Overloading</p>
        </div>

        <!-- Introduction to Polymorphism -->
        <div class="section">
            <div class="section-header">1. Understanding Polymorphism</div>
            <div class="section-content">
                <p>Polymorphism allows objects of different classes to be treated as objects of a common superclass. It enables a single interface to represent different underlying forms (data types).</p>
                
                <h4>1.1 What is Polymorphism?</h4>
                <p>Polymorphism means "many forms". In OOP, it refers to the ability of different classes to be used interchangeably through a common interface.</p>
                
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    class Bird:
                        def fly(self):
                            return "I can fly"
                    
                    class Penguin(Bird):
                        def fly(self):
                            return "I can't fly, but I can swim!"
                    
                    def let_it_fly(bird):
                        print(bird.fly())
                    
                    # Different objects, same method, different behaviors
                    sparrow = Bird()
                    penguin = Penguin()
                    
                    let_it_fly(sparrow)  # I can fly
                    let_it_fly(penguin)  # I can't fly, but I can swim!
                </div>

                <div class="note">
                    <strong>Key Points:</strong>
                    <ul>
                        <li>Polymorphism allows the same method name to be used for different types</li>
                        <li>It promotes code reusability and flexibility</li>
                        <li>Makes the code more intuitive and easier to understand</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Function Overriding -->
        <div class="section">
            <div class="section-header">2. Function Overriding</div>
            <div class="section-content">
                <p>Function overriding occurs when a child class provides a specific implementation of a method that is already defined in its parent class.</p>
                
                <h4>2.1 Basic Method Overriding</h4>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    class Animal:
                        def make_sound(self):
                            return "Some generic animal sound"
                    
                    class Dog(Animal):
                        def make_sound(self):
                            return "Woof!"
                    
                    class Cat(Animal):
                        def make_sound(self):
                            return "Meow!"
                    
                    # Create instances
                    animal = Animal()
                    dog = Dog()
                    cat = Cat()
                    
                    # Same method, different behaviors
                    print(animal.make_sound())  # Some generic animal sound
                    print(dog.make_sound())     # Woof!
                    print(cat.make_sound())     # Meow!
                </div>

                <h4>2.2 Using <code>super()</code> in Overridden Methods</h4>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    class Vehicle:
                        def __init__(self, brand, model):
                            self.brand = brand
                            self.model = model
                        
                        def info(self):
                            return f"{self.brand} {self.model}"
                    
                    class Car(Vehicle):
                        def __init__(self, brand, model, doors):
                            super().__init__(brand, model)
                            self.doors = doors
                        
                        def info(self):
                            # Extend the parent class method
                            return f"{super().info()} with {self.doors} doors"
                    
                    # Create instances
                    vehicle = Vehicle("Generic", "Vehicle")
                    car = Car("Toyota", "Camry", 4)
                    
                    print(vehicle.info())  # Generic Vehicle
                    print(car.info())      # Toyota Camry with 4 doors
                </div>

                <div class="warning">
                    <strong>Important:</strong> When overriding methods, it's often a good practice to call the parent class's method using <code>super()</code> to ensure that the parent's initialization and functionality are preserved.
                </div>
            </div>
        </div>

        <!-- Operator Overloading -->
        <div class="section">
            <div class="section-header">3. Operator Overloading</div>
            <div class="section-content">
                <p>Operator overloading allows the same operator to have different meanings according to the context. In Python, this is achieved by defining special methods in a class.</p>
                
                <h4>3.1 Common Operator Overloading Methods</h4>
                
                <div class="tabs">
                    <div class="tab active" onclick="openTab(event, 'arithmetic')">Arithmetic</div>
                    <div class="tab" onclick="openTab(event, 'comparison')">Comparison</div>
                    <div class="tab" onclick="openTab(event, 'subscript')">Subscript</div>
                    <div class="tab" onclick="openTab(event, 'context')">Context Managers</div>
                </div>

                <div id="arithmetic" class="tab-content active">
                    <h5>Arithmetic Operators</h5>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                        class Vector:
                            def __init__(self, x, y):
                                self.x = x
                                self.y = y
                            
                            # Addition
                            def __add__(self, other):
                                return Vector(self.x + other.x, self.y + other.y)
                            
                            # Subtraction
                            def __sub__(self, other):
                                return Vector(self.x - other.x, self.y - other.y)
                            
                            # Multiplication (scalar)
                            def __mul__(self, scalar):
                                if isinstance(scalar, (int, float)):
                                    return Vector(self.x * scalar, self.y * scalar)
                                return NotImplemented
                            
                            # Reverse multiplication (for scalar * vector)
                            __rmul__ = __mul__
                            
                            # String representation
                            def __str__(self):
                                return f"Vector({self.x}, {self.y})"
                        
                        # Create vectors
                        v1 = Vector(2, 4)
                        v2 = Vector(1, 3)
                        
                        # Test operations
                        print(v1 + v2)   # Vector(3, 7)
                        print(v1 - v2)   # Vector(1, 1)
                        print(v1 * 3)    # Vector(6, 12)
                        print(2 * v2)    # Vector(2, 6) - uses __rmul__
                    </div>
                </div>

                <div id="comparison" class="tab-content">
                    <h5>Comparison Operators</h5>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                        class Fraction:
                            def __init__(self, numerator, denominator=1):
                                self.numer = numerator
                                self.denom = denominator
                            
                            # Equality
                            def __eq__(self, other):
                                if not isinstance(other, Fraction):
                                    return False
                                return self.numer * other.denom == other.numer * self.denom
                            
                            # Less than
                            def __lt__(self, other):
                                return self.numer * other.denom < other.numer * self.denom
                            
                            # Less than or equal
                            def __le__(self, other):
                                return self.numer * other.denom <= other.numer * self.denom
                            
                            # String representation
                            def __str__(self):
                                return f"{self.numer}/{self.denom}"
                        
                        # Create fractions
                        f1 = Fraction(1, 2)
                        f2 = Fraction(2, 4)
                        f3 = Fraction(3, 4)
                        
                        # Test comparisons
                        print(f1 == f2)  # True (1/2 == 2/4)
                        print(f1 < f3)   # True (1/2 < 3/4)
                        print(f3 > f2)   # True (3/4 > 1/2)
                        print(f1 <= f2)  # True (1/2 <= 1/2)
                    </div>
                </div>

                <div id="subscript" class="tab-content">
                    <h5>Subscript and Slicing</h5>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                        class ShoppingCart:
                            def __init__(self):
                                self.items = {}
                            
                            def add_item(self, item, quantity=1):
                                self.items[item] = self.items.get(item, 0) + quantity
                            
                            # Subscript access
                            def __getitem__(self, item):
                                return self.items.get(item, 0)
                            
                            def __setitem__(self, item, quantity):
                                if quantity <= 0:
                                    if item in self.items:
                                        del self.items[item]
                                else:
                                    self.items[item] = quantity
                            
                            def __delitem__(self, item):
                                if item in self.items:
                                    del self.items[item]
                            
                            def __contains__(self, item):
                                return item in self.items
                            
                            def __len__(self):
                                return len(self.items)
                            
                            def __str__(self):
                                return ", ".join(f"{qty}x {item}" for item, qty in self.items.items()) or "Empty"
                        
                        # Create a shopping cart
                        cart = ShoppingCart()
                        
                        # Add items using method
                        cart.add_item("Apple", 3)
                        cart.add_item("Banana", 2)
                        
                        # Subscript access
                        print(cart["Apple"])  # 3
                        
                        # Update quantity
                        cart["Apple"] = 5
                        print(cart["Apple"])  # 5
                        
                        # Check if item exists
                        print("Banana" in cart)  # True
                        
                        # Delete item
                        del cart["Banana"]
                        print("Banana" in cart)  # False
                    </div>
                </div>

                <div id="context" class="tab-content">
                    <h5>Context Managers</h5>
                    <div class="code-block">
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                        class Timer:
                            def __init__(self, name):
                                self.name = name
                            
                            def __enter__(self):
                                import time
                                self.start_time = time.time()
                                print(f"Starting {self.name}...")
                                return self
                            
                            def __exit__(self, exc_type, exc_val, exc_tb):
                                import time
                                elapsed = time.time() - self.start_time
                                print(f"{self.name} took {elapsed:.2f} seconds")
                                # Return False to propagate exceptions, True to suppress them
                                return False
                        
                        # Using the context manager
                        with Timer("long_operation"):
                            # Simulate a long operation
                            import time
                            time.sleep(1.5)
                        
                        # Output:
                        # Starting long_operation...
                        # long_operation took 1.50 seconds
                    </div>
                </div>

                <h4>3.2 Common Special Methods for Operator Overloading</h4>
                <table class="method-table">
                    <tr>
                        <th>Operation</th>
                        <th>Method</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>Addition</td>
                        <td><code>__add__(self, other)</code></td>
                        <td>Implements <code>+</code> operator</td>
                    </tr>
                    <tr>
                        <td>Subtraction</td>
                        <td><code>__sub__(self, other)</code></td>
                        <td>Implements <code>-</code> operator</td>
                    </tr>
                    <tr>
                        <td>Multiplication</td>
                        <td><code>__mul__(self, other)</code></td>
                        <td>Implements <code>*</code> operator</td>
                    </tr>
                    <tr>
                        <td>Division</td>
                        <td><code>__truediv__(self, other)</code></td>
                        <td>Implements <code>/</code> operator</td>
                    </tr>
                    <tr>
                        <td>Equality</td>
                        <td><code>__eq__(self, other)</code></td>
                        <td>Implements <code>==</code> operator</td>
                    </tr>
                    <tr>
                        <td>Less than</td>
                        <td><code>__lt__(self, other)</code></td>
                        <td>Implements <code>&lt;</code> operator</td>
                    </tr>
                    <tr>
                        <td>String representation</td>
                        <td><code>__str__(self)</code></td>
                        <td>Implements <code>str(obj)</code></td>
                    </tr>
                    <tr>
                        <td>Length</td>
                        <td><code>__len__(self)</code></td>
                        <td>Implements <code>len(obj)</code></td>
                    </tr>
                    <tr>
                        <td>Context manager</td>
                        <td><code>__enter__(self)</code>, <code>__exit__(self, ...)</code></td>
                        <td>Implements <code>with</code> statement</td>
                    </tr>
                </table>
            </div>
        </div>

        <!-- Duck Typing -->
        <div class="section">
            <div class="section-header">4. Duck Typing and Polymorphism</div>
            <div class="section-content">
                <p>Python uses "duck typing" - if an object walks like a duck and quacks like a duck, then it must be a duck. This is a form of dynamic typing where the type or class of an object is less important than the methods it defines.</p>
                
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    class Duck:
                        def quack(self):
                            return "Quack!"
                        
                        def fly(self):
                            return "I'm flying!"
                    
                    class Person:
                        def quack(self):
                            return "The person imitates a duck"
                        
                        def fly(self):
                            return "The person takes an airplane"
                    
                    def duck_duck_goose(duck_like_object):
                        print(duck_like_object.quack())
                        print(duck_like_object.fly())
                    
                    # Both objects can be used interchangeably
                    duck = Duck()
                    person = Person()
                    
                    duck_duck_goose(duck)
                    # Output:
                    # Quack!
                    # I'm flying!
                    
                    duck_duck_goose(person)
                    # Output:
                    # The person imitates a duck
                    # The person takes an airplane
                </div>

                <div class="note">
                    <strong>Duck Typing vs. Inheritance:</strong>
                    <ul>
                        <li>Duck typing focuses on what methods/properties an object has, not its actual type</li>
                        <li>Inheritance creates an "is-a" relationship between classes</li>
                        <li>Duck typing creates a "behaves-like" relationship</li>
                        <li>Python's dynamic nature makes duck typing very powerful</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Abstract Base Classes (ABCs) and Polymorphism -->
        <div class="section">
            <div class="section-header">5. Abstract Base Classes and Polymorphism</div>
            <div class="section-content">
                <p>Abstract Base Classes (ABCs) can be used to define a common interface that multiple classes must implement, enabling polymorphism through inheritance.</p>
                
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    from abc import ABC, abstractmethod
                    
                    class Shape(ABC):
                        @abstractmethod
                        def area(self):
                            pass
                        
                        @abstractmethod
                        def perimeter(self):
                            pass
                        
                        def __str__(self):
                            return f"{self.__class__.__name__} - Area: {self.area()}, Perimeter: {self.perimeter()}"
                    
                    class Rectangle(Shape):
                        def __init__(self, width, height):
                            self.width = width
                            self.height = height
                        
                        def area(self):
                            return self.width * self.height
                        
                        def perimeter(self):
                            return 2 * (self.width + self.height)
                    
                    class Circle(Shape):
                        def __init__(self, radius):
                            self.radius = radius
                        
                        def area(self):
                            import math
                            return math.pi * self.radius ** 2
                        
                        def perimeter(self):
                            import math
                            return 2 * math.pi * self.radius
                    
                    # Create a list of shapes
                    shapes = [Rectangle(4, 5), Circle(3)]
                    
                    # Process shapes polymorphically
                    for shape in shapes:
                        print(shape)  # Calls the appropriate area() and perimeter()
                        
                    # Output:
                    # Rectangle - Area: 20, Perimeter: 18
                    # Circle - Area: 28.274333882308138, Perimeter: 18.84955592153876
                </div>

                <div class="warning">
                    <strong>Best Practice:</strong> Use ABCs when you want to define a common interface that multiple classes should implement. This makes your code more maintainable and self-documenting, and it helps catch errors at definition time rather than at runtime.
                </div>
            </div>
        </div>

        <!-- Practice Exercise -->
        <div class="section">
            <div class="section-header">6. Practice Exercise</div>
            <div class="section-content">
                <h4>Task: Create a Simple Banking System</h4>
                <p>Implement a simple banking system with different account types that demonstrate polymorphism.</p>
                
                <div class="code-block">
                    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    from abc import ABC, abstractmethod
                    
                    class Account(ABC):
                        def __init__(self, account_number, balance=0):
                            self.account_number = account_number
                            self.balance = balance
                        
                        @abstractmethod
                        def deposit(self, amount):
                            pass
                        
                        @abstractmethod
                        def withdraw(self, amount):
                            pass
                        
                        def __str__(self):
                            return f"Account {self.account_number}: Balance = ${self.balance:.2f}"
                    
                    # Implement the following classes:
                    # 1. SavingsAccount: Can't withdraw more than balance
                    # 2. CheckingAccount: Allows overdraft up to a limit
                    # 3. CreditAccount: Has a credit limit and charges interest on negative balance
                    
                    # Test your implementation
                    if __name__ == "__main__":
                        # accounts = [
                        #     SavingsAccount("SAV001", 1000),
                        #     CheckingAccount("CHK001", 500, overdraft_limit=200),
                        #     CreditAccount("CRD001", 0, credit_limit=1000, interest_rate=0.02)
                        # ]
                        # 
                        # for account in accounts:
                        #     print("-" * 40)
                        #     print(f"Initial: {account}")
                        #     
                        #     # Test deposit
                        #     account.deposit(200)
                        #     print(f"After deposit: {account}")
                        #     
                        #     # Test withdraw
                        #     result = account.withdraw(300)
                        #     print(f"Withdraw result: {result}")
                        #     print(f"After withdraw: {account}")
                        pass
                </div>
                
                <h5>Requirements:</h5>
                <ol>
                    <li>Create an abstract <code>Account</code> class with the specified methods</li>
                    <li>Implement three account types with different withdrawal behaviors</li>
                    <li>Each account should have a unique account number and balance</li>
                    <li>Implement the <code>__str__</code> method for each class</li>
                    <li>Test your implementation with different scenarios</li>
                </ol>
            </div>
        </div>

        <!-- Course Summary -->
        <div class="section">
            <div class="section-header">7. Course Summary</div>
            <div class="section-content">
                <h4>Key Concepts Covered in Unit-V:</h4>
                <ol>
                    <li><strong>Object-Oriented Programming</strong>: Classes, objects, and the four pillars of OOP</li>
                    <li><strong>Constructors & Special Methods</strong>: <code>__init__</code>, <code>__new__</code>, and other magic methods</li>
                    <li><strong>Inheritance</strong>: Single, multiple, multi-level, and hierarchical inheritance</li>
                    <li><strong>Abstract Base Classes</strong>: Creating interfaces with <code>@abstractmethod</code></li>
                    <li><strong>Polymorphism</strong>: Function overriding and operator overloading</li>
                    <li><strong>Encapsulation</strong>: Public, protected, and private members</li>
                    <li><strong>Garbage Collection</strong>: Reference counting and circular references</li>
                </ol>
                
                <div class="success">
                    <strong>Congratulations!</strong> You've completed the Python OOP course. You now have a solid understanding of object-oriented programming in Python and are ready to build complex, maintainable applications.
                </div>
            </div>
        </div>

        <!-- Navigation -->
        <div class="navigation">
            <a href="lecture-3.html" class="btn">‚Üê Previous: Inheritance & Abstract Classes</a>
            <span class="btn btn-secondary">End of Unit-V</span>
        </div>
    </div>

    <script>
        // Copy code button functionality
        function copyCode(button) {
            const codeBlock = button.parentElement;
            const code = codeBlock.textContent.replace('Copy', '').trim();
            navigator.clipboard.writeText(code).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            });
        }

        // Tab functionality
        function openTab(evt, tabName) {
            const tabContents = document.getElementsByClassName('tab-content');
            const tabs = document.getElementsByClassName('tab');
            
            // Hide all tab content
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].style.display = 'none';
                tabs[i].classList.remove('active');
            }
            
            // Show the current tab and mark button as active
            document.getElementById(tabName).style.display = 'block';
            evt.currentTarget.classList.add('active');
        }

        // Initialize first tab as active
        document.addEventListener('DOMContentLoaded', function() {
            const firstTab = document.querySelector('.tab');
            if (firstTab) firstTab.click();
        });
    </script>
</body>
</html>
